[{"path":"/database/psql/column-order","content":"<h1 id=\"column-order\">Column Order</h1>\n<p><a href=\"https://www.2ndquadrant.com/en/blog/on-rocks-and-sand/\">https://www.2ndquadrant.com/en/blog/on-rocks-and-sand/</a></p>\n<p>|-/|Tags|-/|-psql,postgres,database-|-/|Tags|-/|</p>","pathSegments":["database","psql","column-order"],"name":"Column Order","tags":["psql","postgres","database"],"lastModified":"2020-01-22"},{"path":"/database/psql/explain-analyze","content":"<h1 id=\"explain--analyze\">Explain / Analyze</h1>\n<ul>\n<li><code>EXPLAIN</code> is used in PSQL to view the execution plan to be used when for the given command</li>\n</ul>\n<pre><code>EXPLAIN SELECT * FROM my_table\nEXPLAIN DELETE FROM my_table\nEXPLAIN UPDATE my_table WHERE foo=&#39;bar&#39;</code></pre><ul>\n<li><code>EXPLAIN ANALYZE</code> returns the execution plan but also performs the command and provided details on actual performance</li>\n</ul>\n<pre><code>EXPLAIN ANALYZE SELECT * FROM my_table\nEXPLAIN ANALYZE DELETE FROM my_table\nEXPLAIN ANALYZE UPDATE my_table WHERE foo=&#39;bar&#39;</code></pre><h2 id=\"reading-an-execution-plan\">Reading an execution plan</h2>\n<p><strong>Example 1 Query</strong></p>\n<pre><code>EXPLAIN ANALYZE SELECT * FROM my_table WHERE age &lt; 23</code></pre><p><strong>Example 1 Execution Plan</strong></p>\n<pre><code>Seq Scan on my_table (cost=0.00..25.88 rows=423 width=36) (actual time=0.010..0.011 rows=1 loops=1)</code></pre><ul>\n<li><code>Seq Scan on my_table</code>: This identifys the action to be taken and the table it intends to work against</li>\n<li><code>(cost=0.00..25.88 rows=423 width=36)</code><ul>\n<li><code>cost=0.00..25.88</code>: The estimated cost (arbitrary units which conventionally mean disk page fetches) to run the action. <ul>\n<li>The first value (0.00 in this example) indicates cost required to start the action</li>\n<li>The second value (25.88 in this example) indicates cost to perform the action</li>\n</ul>\n</li>\n<li><code>rows=423</code>: The estimated number of rows to be output</li>\n<li><code>width=36</code>: The estimated size in bytes of a single row</li>\n</ul>\n</li>\n<li><code>(actual time=0.010..0.011 rows=1 loops=1)</code><ul>\n<li><code>time=0.010..0.011</code>: The time (in milliseconds) to execute the command</li>\n<li><code>rows=1</code>: The number of rows returned by the command</li>\n<li><code>loops=1</code>: The number of times the action repeated (if greater then 1 actual time and rows are an average of every execution)</li>\n</ul>\n</li>\n</ul>\n<hr>\n<p><strong>Example 2 Query</strong></p>\n<pre><code>EXPLAIN SELECT * FROM tenk1 WHERE unique1 &lt; 100 AND unique2 &gt; 9000;</code></pre><p><strong>Example 2 Execution Plan</strong></p>\n<pre><code>Bitmap Heap Scan on tenk1  (cost=25.08..60.21 rows=10 width=244)\n   Recheck Cond: ((unique1 &lt; 100) AND (unique2 &gt; 9000))\n   -&gt;  BitmapAnd  (cost=25.08..25.08 rows=10 width=0)\n         -&gt;  Bitmap Index Scan on tenk1_unique1  (cost=0.00..5.04 rows=101 width=0)\n               Index Cond: (unique1 &lt; 100)\n         -&gt;  Bitmap Index Scan on tenk1_unique2  (cost=0.00..19.78 rows=999 width=0)\n               Index Cond: (unique2 &gt; 9000)</code></pre><p>In this example multiple actions are required. The first actions to execute are those most deeply nested (there is no order guarantee for those on the same level). </p>\n<p>With nested execution plans the cost is cumulative for all sub actions. The costs for <code>Bitmap Index Scan on tenk1_unique1</code> and <code>Bitmap Index Scan on tenk1_unique2</code> represent the cost for that action only as these have no nested actions. However, the cost for <code>Bitmap Heap Scan on tenk1</code> includes the cost for the sub actions.  </p>\n<h2 id=\"considerations-with-execution-plans\">Considerations with execution plans</h2>\n<ul>\n<li>Costs do not include network transmission costs or I/O conversion costs </li>\n<li>The measurement overhead added by EXPLAIN ANALYZE can be significant</li>\n<li><code>EXPLAIN ANALYZE</code> will result in side effect when used with update and delete (don&#39;t accidentally delete an entire table)</li>\n</ul>\n<h1 id=\"references\">References</h1>\n<p><a href=\"https://thoughtbot.com/blog/reading-an-explain-analyze-query-plan\">Reading a Postgres EXPLAIN ANALYZE Query Plan/thoughtbot</a>\n<a href=\"https://www.postgresql.org/docs/9.3/sql-explain.html\">EXPLAIN/postgresql</a>\n<a href=\"https://www.postgresql.org/docs/9.4/using-explain.html\">Using EXPLAIN/postgresql</a></p>\n<p>|-/|Tags|-/|-psql,postgres,database,query-plan,explain,explain-analyze-|-/|Tags|-/|</p>","pathSegments":["database","psql","explain-analyze"],"name":"Explain Analyze","tags":["psql","postgres","database","query-plan","explain","explain-analyze"],"lastModified":"2020-01-22"},{"path":"/database/psql/grouping-sets","content":"<h1 id=\"grouping-sets\">Grouping sets</h1>\n<p><code>GROUPING SETS</code> is used to include multiple grouping conditions in a single query. The same result could be achieved by combining multiple queries with <code>UNION ALL</code> however this would be inefficent. <code>GROUPING SETS</code> computes the result with a single pass over the data and so is more performant than individual queries.</p>\n<pre><code>SELECT gender, country\nFROM person \nGROUP BY \n    GROUPING SETS (\n      (gender, country),\n      (gender),\n      (country),\n      ()\n);</code></pre><p><code>GROUPING SETS</code> also supports composite columns, allowing for grouping based on the values in multiple columns. </p>\n<pre><code>SELECT gender, country\nFROM person \nGROUP BY \n    GROUPING SETS ((gender, country));</code></pre><h2 id=\"cube\">CUBE</h2>\n<p>The subclause <code>CUBE</code> is used to define all variations of grouping sets. The following examples will produce the same result.</p>\n<pre><code>SELECT gender, country, eye_colour\nFROM person \nGROUP BY CUBE(gender, country, eye_colour);</code></pre><pre><code>SELECT gender, country, eye_colour\nFROM person \nGROUP BY \n    GROUPING SETS (\n      (gender, country, eye_colour),\n      (gender, country),\n      (gender, eye_colour),\n      (country, eye_colour),\n      (gender),\n      (country),\n      (eye_colour),\n      ()\n);</code></pre><h2 id=\"rollup\">ROLLUP</h2>\n<p>The subclause <code>ROLLUP</code> is used to define subset of grouping set variations based on the order of the columns provided. The following examples will produce the same result.</p>\n<pre><code>SELECT gender, country, eye_colour\nFROM person \nGROUP BY ROLLUP(gender, country, eye_colour);</code></pre><pre><code>SELECT gender, country, eye_colour\nFROM person \nGROUP BY \n    GROUPING SETS (\n      (gender, country, eye_colour),\n      (gender, country),\n      (gender),\n      ()\n);</code></pre><h1 id=\"references\">References</h1>\n<p><a href=\"https://www.waitingforcode.com/sql/sql-grouping-sets-operator/read\">sql-grouping-sets-operator/waitingforcode</a>\n<a href=\"http://www.postgresqltutorial.com/postgresql-grouping-sets/\">postgresql-grouping-sets/postgresqltutorial</a>\n<a href=\"https://stackoverflow.com/questions/25274879/when-to-use-grouping-sets-cube-and-rollup\">When to use GROUPING SETS, CUBE and ROLLUP/stackoverflow</a>\n<a href=\"https://docs.snowflake.net/manuals/sql-reference/constructs/group-by-grouping-sets.html\">group-by-grouping-sets/snowflake</a>\n<a href=\"http://www.postgresqltutorial.com/postgresql-cube/\">postgresql-cube/postgresqltutorial</a>\n<a href=\"http://www.postgresqltutorial.com/postgresql-rollup/\">postgresql-rollup/postgresqltutorial</a></p>\n<p>|-/|Tags|-/|-psql,postgres,database,grouping-sets,cube,rollup-|-/|Tags|-/|</p>","pathSegments":["database","psql","grouping-sets"],"name":"Grouping Sets","tags":["psql","postgres","database","grouping-sets","cube","rollup"],"lastModified":"2020-01-22"},{"path":"/database/psql/psql-drop-all-tables-in-schema","content":"<h1 id=\"dropping-all-tables-in-a-schema\">Dropping all tables in a schema</h1>\n<ul>\n<li>Build a number of drop table queries based on the table <code>pg_tables</code> and then execute them.</li>\n</ul>\n<pre><code>DO $$ DECLARE tablename RECORD;\n\nBEGIN\n\n  FOR tablename IN (\n    SELECT pg_tables.tablename\n    FROM pg_tables \n    WHERE schemaname = &#39;public&#39; -- Update the schema if needed\n  ) LOOP\n    EXECUTE &#39;drop table if exists &quot;&#39; || tablename || &#39;&quot; cascade;&#39;;\n  END LOOP;\n\nEND $$;</code></pre><ul>\n<li>Drop the schema that contains the tables of interest</li>\n</ul>\n<pre><code>DROP SCHEMA public CASCADE;\nCREATE SCHEMA public;\nGRANT ALL ON SCHEMA public TO postgres;\nGRANT ALL ON SCHEMA public TO public;\nCOMMENT ON SCHEMA public IS &#39;standard public schema&#39;;</code></pre><p>|-/|Tags|-/|-psql,postgres,database,table,tables,drop,delete,schema-|-/|Tags|-/|</p>\n<h1 id=\"references\">References</h1>\n<p><a href=\"https://stackoverflow.com/questions/3327312/how-can-i-drop-all-the-tables-in-a-postgresql-database\">StackOverflow: How can I drop all the tables in a PostgreSQL database?</a></p>","pathSegments":["database","psql","psql-drop-all-tables-in-schema"],"name":"Psql Drop All Tables In Schema","tags":["psql","postgres","database","table","tables","drop","delete","schema"],"lastModified":"2020-01-22"},{"path":"/database/psql/returning-a-set-amount-of-results","content":"<h1 id=\"returning-a-set-amount-of-results\">Returning a Set Amount of Results</h1>\n<p>In psql the two ways to return a specific number of results</p>\n<p><code>limit</code> and <code>fetch</code></p>\n<h2 id=\"use-of-limit\">Use of Limit</h2>\n<p><code>SELECT * FROM table ORDER BY id LIMIT 100</code>\n<code>SELECT * FROM table ORDER BY id LIMIT 100 OFFSET 50</code></p>\n<h2 id=\"use-of-fetch\">Use of Fetch</h2>\n<p><code>SELECT * FROM table ORDER BY id FETCH NEXT 100 ROWS ONLY</code>\n<code>SELECT * FROM table ORDER BY id OFFSET 50 FETCH NEXT 100 ROWS ONLY</code></p>\n<h2 id=\"what-is-the-difference\">What is the difference</h2>\n<p>There is no performance difference between the two. The only difference is syntactic.</p>\n<h1 id=\"references\">References</h1>\n<p><a href=\"http://www.postgresqltutorial.com/postgresql-fetch/\">postgresql-fetch (http://www.postgresqltutorial.com)</a>\n<a href=\"https://www.postgresql.org/docs/10/sql-fetch.html\">sql-fetch (www.postgresql.org)</a>\n<a href=\"https://docs.snowflake.net/manuals/sql-reference/constructs/limit.html\">LIMIT / FETCH (docs.snowflake.net)</a></p>\n<p>|-/|Tags|-/|-psql,postgres,database,pagination,limit,fetch,offset-|-/|Tags|-/|</p>","pathSegments":["database","psql","returning-a-set-amount-of-results"],"name":"Returning A Set Amount Of Results","tags":["psql","postgres","database","pagination","limit","fetch","offset"],"lastModified":"2020-01-22"},{"path":"/database/psql/reviewing-database-size","content":"<h1 id=\"database-size\">Database size</h1>\n<h2 id=\"table-size\">Table size</h2>\n<ul>\n<li>The size of a table</li>\n</ul>\n<pre><code>select pg_size_pretty (pg_relation_size(&#39;table_name&#39;));</code></pre><ul>\n<li>The size of a table including indexes and additional objects</li>\n</ul>\n<pre><code>SELECT\n    pg_size_pretty (\n        pg_total_relation_size (&#39;table_name&#39;)\n    );</code></pre><ul>\n<li>All tables sizes</li>\n</ul>\n<pre><code>SELECT\n    relname AS &quot;relation&quot;,\n    pg_size_pretty (\n        pg_total_relation_size (C.oid)\n    ) AS &quot;total_size&quot;\nFROM\n    pg_class C\nLEFT JOIN pg_namespace N ON (N.oid = C.relnamespace)\nWHERE\n    nspname NOT IN (\n        &#39;pg_catalog&#39;,\n        &#39;information_schema&#39;\n    )\nAND C.relkind &lt;&gt; &#39;i&#39;\nAND nspname !~ &#39;^pg_toast&#39;\nORDER BY\n    pg_total_relation_size (C.oid) DESC</code></pre><h2 id=\"database-size-1\">Database size</h2>\n<ul>\n<li>The size of a database</li>\n</ul>\n<pre><code>SELECT\n    pg_size_pretty (\n        pg_database_size (&#39;database_name&#39;)\n    );</code></pre><ul>\n<li>The size of all databases on a server</li>\n</ul>\n<pre><code>SELECT\n    pg_database.datname,\n    pg_size_pretty(pg_database_size(pg_database.datname)) AS size\n    FROM pg_database;</code></pre><h2 id=\"other-size-functions\">Other size functions</h2>\n<ul>\n<li>The size of Indexes associated with a table </li>\n</ul>\n<pre><code>SELECT pg_size_pretty (pg_indexes_size(&#39;table_name&#39;));</code></pre><ul>\n<li>Values size </li>\n</ul>\n<pre><code>SELECT pg_column_size(5::smallint);</code></pre><h1 id=\"references\">References</h1>\n<p><a href=\"http://www.postgresqltutorial.com/postgresql-database-indexes-table-size/\">How to Get Table, Database, Indexes, Tablespace, and Value Size in PostgreSQL/postgresqltutorial</a></p>\n<p>|-/|Tags|-/|-psql,postgres,database,-|-/|Tags|-/|</p>","pathSegments":["database","psql","reviewing-database-size"],"name":"Reviewing Database Size","tags":["psql","postgres","database",""],"lastModified":"2020-01-22"},{"path":"/database/psql/the-like-operator","content":"<h1 id=\"the-like-operator\">The LIKE operator</h1>\n<p>This operator performs queries using patterns to match against a range of results</p>\n<p><code>%</code> - matches any sequence of characters\n<code>_</code> - matches any single character</p>\n<p><code>SELECT * FROM table WHERE text LIKE &#39;_search_&#39;</code>\n<code>SELECT * FROM table WHERE text LIKE &#39;text-%&#39;</code></p>\n<h2 id=\"ilike\">ILIKE</h2>\n<p><code>ILIKE</code> can be used in the same way as <code>LIKE</code> only it match is case insensitive.</p>\n<p>|-/|Tags|-/|-psql,postgres,database,like,pattern,match-|-/|Tags|-/|</p>\n<h1 id=\"references\">References</h1>\n<p><a href=\"http://www.postgresqltutorial.com/postgresql-like/\">postgresql-like (http://www.postgresqltutorial.com/postgresql-like/)</a></p>","pathSegments":["database","psql","the-like-operator"],"name":"The Like Operator","tags":["psql","postgres","database","like","pattern","match"],"lastModified":"2020-01-22"},{"path":"/database/psql/window-functions","content":"<!-- TOC -->\n\n<ul>\n<li><a href=\"#window-functions\">Window Functions</a></li>\n</ul>\n<!-- /TOC -->\n\n\n<h1 id=\"window-functions\">Window Functions</h1>\n<p>|-/|Tags|-/|-psql,postgres,database,-|-/|Tags|-/|</p>","pathSegments":["database","psql","window-functions"],"name":"Window Functions","tags":["psql","postgres","database",""],"lastModified":"2020-01-22"}]
